---
title: 问题总结
date: 2019-10-10 09:32:48
tags:
---
## 一、原生js基础相关
#### 变量区分大小写
#### 1、数据类型有哪些
    基本数据类型(存放在栈中)：string、number、boolean、null、undefined、symbol
    引用类型(存放在堆中)：object、function
**注意1:** 栈和堆的区别
    栈（stack）为自动分配的内存空间, 它由系统自动释放; 而堆（heap）则是动态分配的内存, 大小不定也不会自动释放
**注意2:** null和undefined的区别
    typeof undefined   // undefined
    typeof null        // object
    null === undefined // false
    null == undefined  // true
#### 2、如何判断数据的类型
    typeof 可以正确的判断基本数据类型的类型, 但是对于对象, 都是object, 对于函数都是function
    ``` bash
        typeof [] === 'object'
        typeof {} === 'object'
        typeof alert === 'function'
        typeof null === 'object' (一个存在很久的bug)
    ```
#### 3、判断是不是某构造函数的实例 
    instanceof：通过原型链判断
    ``` bash
        function Person (name) {
            this.name = name
        }
        let p1 = new Person('张三')
        p1 instanceof Person // true p1是构造函数Person的实例
        Person[Symbol.hasInstance](p1) // true 与上面等价
    ```
    自定义instanceof方法
    ``` bash
        function MyInstance (value) {
            return [Symbol.hasInstance](value) {
                return Number(value) % 2 === 0;
            }
        }
        let p1 = new Person('张三')
        p1 instanceof Person // true p1是构造函数Person的实例
        Person[Symbol.hasInstance](p1) // true 与上面等价
    ```

#### 4、等号赋值、浅拷贝、深拷贝的区别
https://www.haorooms.com/post/js_copy_sq
等号赋值：新数据和原数据指向同一引用
浅拷贝：新数据和原数据不指向同一个引用, 如果原数据里包含子对象, 新旧子对象共享同一块内存
深拷贝：会另外创造一个一模一样的对象, 新对象跟原对象不共享内存, 修改新对象不会改到原对象
    ``` bash
        #####浅拷贝的实现方式:

        第一种：lodash的方法_.cclone
        第二种：... 
        第三种：Object.assgin(), 注意：obj里必须含有子对象
        var obj = { a: {msg: "hello", num: 21}, b:3 };
        var cloneObj = Object.assign({}, obj);
        obj === cloneObj; // false
        obj.a.num = 66;
        obj.b = 10;
        console.log(cloneObj.a.num); // 66
        console.log(cloneObj.b); // 3
        第四种：自定义方法
        function shallowClone(initalObj) {    
            var obj = {};    
            for ( var i in initalObj) {
                obj[i] = initalObj[i];
            }    
            return obj;
        }
        var obj = {
            a: "hello",
            b: {
                a: "world",
                b: 21
            },
            c: ["Bob", "Tom", "Jenny"],
            d: function() {
                alert("hello world");
            }
        }
        var cloneObj = shallowClone(obj); 
        cloneObj === obj; // false
        // 新数据和原数据的b、c、d指向同一引用
        cloneObj.b.a = "changed"; // obj和cloneObj都改变
        cloneObj.c[0] = 6; // obj和cloneObj都改变
        cloneObj.d = function() { alert("changed"); } // obj的d属性不改变

        #####深拷贝的实现方式:
        第一种：用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象
        第二种：对象只有一层的话可以使用上面的：Object.assign()函数
        第三种：自定义方法，递归拷贝
        第四种：lodash的_.cloneDeep
    ```

#### 5、什么是闭包, 闭包的作用, 为什么要使用闭包
匿名函数本身也是一个闭包
闭包：函数A里面有一个函数B, 函数B可以访问到函数A里面的局部变量, 函数B就是闭包
本质：闭包是将函数内部和函数外部连接起来的桥梁
作用：1、可以读取函数内部的变量 2、让一些变量始终保持在内存中
为什么要使用闭包：在函数外部无法读取函数内部的局部变量, 如果想要获取, 可以在函数里在声明一个函数
``` bash
// 想要在函数外部获取f1里面的变量n, 所以需要在f1里声明一个f2, 并作为返回值
function f1() {
    var n = 999;
    nAdd = function() {n += 1}; // 没用var声明, 则是全局变量
    function f2(){
        alert(n);
    }
    return f2; // f2就是闭包
}
var result = f1();
result(); // 999
nAdd();
result(); // 1000
```
1、首先函数f1执行后将f2赋给了全局变量result，所以f2始终在内存中，函数f2在函数f1内部，所以在f2的内部可以访问到f1的变量n。
2、因为f2的存在依赖了f1中的变量n，所以使得f1也始终被存储在了内存中，在调用之后，不会被垃圾回收机制回收。（内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被释放,因为闭包需要它们）
#### 6、构造函数和继承
A为父类, 在子类B的构造函数里调用父类的构造函数，子类的原型指向父类的实例
实例化new 的过程中会发生以上四件事情：
    a、新生成了一个对象
    b、链接到原型
    c、绑定 this
    d、返回新对象
#### 7、什么是原型？什么是原型链
构造函数的prototype属性指向原型,原型的constructor属性指回构造函数,实例的_proto_指向原型。
所有实例共享原型上的属性和方法
#### 9、浏览器端缓存
cookie：与服务器端通信,每次都会携带在HTTP头中。cookie的长度和数量受限制,每个domain最多只能有20条cookie,每个cookie长度不能超过4KB。否则会被截掉。
sessionStorage: 仅在当前会话下有效,关闭页面或浏览器后被清除,存放数据大小为一般为5MB,在客户端中保存,不参与和服务器的通信
localStorage：存放数据大小为一般为5MB,在客户端中保存,不参与和服务器的通信
#### 10、同步和异步、并发和并行、多线程和单线程
#### 11、for循环有哪些方法及区别
``` bash
    let arr = [2,4,1,5,7]
    arr.length= 5
    let obj = {name: '张三', age: 12}
    let str = 'abcdefg123'
    // 支持数组、字符串
    for (let i=0;i<=str.length-1;i++) {
        console.log(i, arr[i]) // i是索引
    }
    //  支持数组、字符串、对象
    // 缺点(针对数组)：可以将属性打印出来
    for (let i in arr) {
        console.log(i, arr[i]) // i是索引0,1,2,3,4,length
    }
    //  支持数组、字符串(es6提出,解决for-in的缺陷, 只返回具有数字索引的属性)
    for (let value of arr) {
        console.log(value) // value 是值, 不是索引
    }
``` 
#### 12、箭头函数和普通函数的this
箭头函数：如果包裹在函数中, 只取决包裹箭头函数的第一个普通函数的this
普通函数：this由函数调用时决定
#### 13、break、continue、return的区别
#### 14、forEach、map、filter的区别
#### 15、字符串有哪些方法、数组有哪些方法
#### 17、什么是对象, 面向对象和面向过程的区别
对象：拥有属性和方法的集合。在js里一切皆对象, 小轿车就是一个对象, 拥有轮胎、窗等属性, 方法有启动停止等
面向对象：封装, 继承, 多态的特点。碰到相同的问题可以直接调用
面向过程：分析出解决问题所需要的步骤, 然后用函数把这些步骤一步一步实现
举例：洗碗
面向过程：先把碗放到水池里 -> 放水 -> 倒洗洁精 -> 用抹布洗 -> 冲洗 -> 拿出来晾干
面向对象：封装一个洗碗机
#### 18、长连接
websocket：服务端主动向客户端推送消息

## 二、ajax请求相关
#### 1、post和get的区别
#### 2、什么是跨域, 跨域有哪些解决方法

## 二、性能优化相关
#### 1、如何优化性能

## 三、es6相关
#### 1、let、var、const声明变量
    let：声明的变量不能再重新声明, 可以修改值
    const：声明的变量不能再重新声明, 如果是基本数据类型, 则不能修改值, 引用类型, 可以改
    var：变量可以声明多次, 后面的会替代前面的(存在变量提升), 
    ``` bash
        console.log(name) // ''
        console.log(name2) // 报错
        getName() // name的值 ''
        function getName () {
            console.log('name的值', name)
        }
        var name = '张三'
        getName() // name的值 张三
        let name2 = '李四'
    ``` 
#### 1、什么是类, 类的继承
class 、extends
#### 2、promise
#### 3、async、await
#### 4、为什么会有es6

## 四、css、html相关
#### 1、什么是盒模型, IE盒模型和标准盒模型的区别
#### 2、什么是html语义化
#### 3、position定位属性有哪些, 都是相对什么定位
#### 4、一个元素水平垂直居中 有哪些方法
#### 5、主流浏览器有哪些兼容性问题
#### 6、哪些标签是不能嵌套使用的
#### 7、display有哪些属性
#### 8、浏览器端的渲染机制

## 五、React框架相关
#### 1、生命周期

## 六、webpack打包相关
#### 1、打包原理


let arr = [1,2,3]
let arr2 = arr