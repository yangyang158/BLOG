---
title: 构造函数及原型链
date: 2019-05-12 20:18:11
tags:
---

## 一、es5 最简单的构造函数和原型链
``` bash
function Person () {
    // 构造函数的属性和方法
    this.name = '张三';
    this.age = 15;
    // 实例方法
    this.run = function () {
        alert(this.name + '正在运动')
    }
}
// 原型链上添加方法和属性(会被多个实例共享, 构造函数不会)
Person.prototype.sex = '男'
Person.prototype.work = function () {
    alert(this.name + '正在工作')
}
// 静态方法(不需要实例化就可以调用)
Person.getInfo = function () {
    alert('获取我的信息')
}
// 调用静态方法
Person.getInfo();// 获取我的信息
// 实例化
var p = new Person()
p.run(); // 张三正在运动
p.work(); // 张三正在工作
```

## 二、es5 继承，实现一个web类继承Person
实现继承的方法：原型链+对象冒充
``` bash
function Person (name, age) {
    this.name = name;
    this.age = age;
    this.run = function () {
        alert(this.name + '正在运动')
    }
}
Person.prototype.sex = '男'
Person.prototype.work = function () {
    alert(this.name + '正在工作')
}

function Web (name, age) {
    // 对象冒充可以继承构造函数里面的属性和方法, 没法继承原型链上的属性和方法
    Person.call(this, name, age);
}
// 原型链继承：可以继承原型链上的属性和方法; 也可以继承构造函数里面的属性和方法, 但是实例化子类时没法给父类传参, 即：w1.name = undefined
Web.prototype = new Person(); => Web.prototype = Person.prototype;

var w1 = new Web('张三', 12)

```

## 三、es6的class、继承：super、extends
将上述的构造函数用class实现
``` bash
class Person {
    // 实例化的时候调用
    constructor (name, age) {
        // 类似上述的Person构造函数
        this.name = name;
        this.age = age;
        this.run = function () {
            alert(this.name + '正在运动')
        }
    }
    // 类的所有方法|属性都是定义在类的prototype属性上面
    sex: '男',
    work() {
        alert(this.name + '正在工作')
    }
}
var p1 = new Person('李四', 12)

class Web extends Person {
    constructor(name, age) {
        super(name, age);// 调用父类的构造函数constructor
    }
    // 扩充自己的方法和属性, 如果子类和父类拥有共同的方法则调用自己的方法
    study() {
        alert(this.name, '在学习')
    }
}
var w1= new Web('wuwu', 12)
w1.work();// wuwu正在工作
```

